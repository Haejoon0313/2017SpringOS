!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.8	//
CACHE_MAX_SECTOR_NO	cache.c	17;"	d	file:
CACHE_MAX_SECTOR_NO	cache.h	9;"	d
DIRECT_CNT	inode.c	16;"	d	file:
DOUBLY_INDIRECT_CNT	inode.c	18;"	d	file:
FILESYS_CACHE_H	cache.h	2;"	d
FILESYS_DIRECTORY_H	directory.h	2;"	d
FILESYS_FILESYS_H	filesys.h	2;"	d
FILESYS_FILE_H	file.h	2;"	d
FILESYS_FREE_MAP_H	free-map.h	2;"	d
FILESYS_FSUTIL_H	fsutil.h	2;"	d
FILESYS_INODE_H	inode.h	2;"	d
FILESYS_OFF_T_H	off_t.h	2;"	d
FREE_MAP_SECTOR	filesys.h	8;"	d
INDIRECT_CNT	inode.c	17;"	d	file:
INODE_MAGIC	inode.c	14;"	d	file:
NAME_MAX	directory.h	12;"	d
PROTd	off_t.h	13;"	d
ROOT_DIR_SECTOR	filesys.h	9;"	d
buffer	cache.h	/^				uint8_t buffer[DISK_SECTOR_SIZE]; \/*data of cache *\/$/;"	m	struct:cache
byte_to_sector	inode.c	/^byte_to_sector (const struct inode *inode, off_t pos) $/;"	f	file:
bytes_to_sectors	inode.c	/^bytes_to_sectors (off_t size)$/;"	f	file:
cache	cache.h	/^struct cache{$/;"	s
cache_init	cache.c	/^void cache_init(void){$/;"	f
cache_list	cache.c	/^static struct list cache_list;$/;"	v	typeref:struct:list	file:
cache_lock	cache.c	/^static struct lock cache_lock;$/;"	v	typeref:struct:lock	file:
cache_lock_acquire	cache.c	/^void cache_lock_acquire(void){$/;"	f
cache_lock_release	cache.c	/^void cache_lock_release(void){$/;"	f
cache_read	cache.c	/^void cache_read(disk_sector_t sec_no, void *read_buffer, int sector_offset, int size){$/;"	f
cache_write	cache.c	/^void cache_write(disk_sector_t sec_no, void* write_buffer, int sector_offset, int size){$/;"	f
data	inode.h	/^				struct inode_disk data; \/*Inode contents*\/$/;"	m	struct:inode	typeref:struct:inode::inode_disk
deny_write	file.c	/^    bool deny_write;            \/* Has file_deny_write() been called? *\/$/;"	m	struct:file	file:
deny_write_cnt	inode.h	/^				int deny_write_cnt;			\/*0:writes ok, >0 deny write*\/$/;"	m	struct:inode
destroy_cache_list	cache.c	/^void destroy_cache_list(void){$/;"	f
dir	directory.c	/^struct dir $/;"	s	file:
dir_add	directory.c	/^dir_add (struct dir *dir, const char *name, disk_sector_t inode_sector) $/;"	f
dir_close	directory.c	/^dir_close (struct dir *dir) $/;"	f
dir_create	directory.c	/^dir_create (disk_sector_t sector, size_t entry_cnt) $/;"	f
dir_entry	directory.c	/^struct dir_entry $/;"	s	file:
dir_get_inode	directory.c	/^dir_get_inode (struct dir *dir) $/;"	f
dir_lookup	directory.c	/^dir_lookup (const struct dir *dir, const char *name,$/;"	f
dir_open	directory.c	/^dir_open (struct inode *inode) $/;"	f
dir_open_root	directory.c	/^dir_open_root (void)$/;"	f
dir_readdir	directory.c	/^dir_readdir (struct dir *dir, char name[NAME_MAX + 1])$/;"	f
dir_remove	directory.c	/^dir_remove (struct dir *dir, const char *name) $/;"	f
dir_reopen	directory.c	/^dir_reopen (struct dir *dir) $/;"	f
direct	inode.h	/^				disk_sector_t direct[64];$/;"	m	struct:inode_disk
dirty	cache.h	/^				bool dirty;												\/*is dirty cache? *\/$/;"	m	struct:cache
do_format	filesys.c	/^do_format (void)$/;"	f	file:
doubly_indirect	inode.h	/^				disk_sector_t doubly_indirect;$/;"	m	struct:inode_disk
el	cache.h	/^				struct list_elem el;							\/*list element *\/	$/;"	m	struct:cache	typeref:struct:cache::list_elem
elem	inode.h	/^				struct list_elem elem;	\/*element in inode list*\/$/;"	m	struct:inode	typeref:struct:inode::list_elem
evict_cache	cache.c	/^bool evict_cache(void){$/;"	f
file	file.c	/^struct file $/;"	s	file:
file_allow_write	file.c	/^file_allow_write (struct file *file) $/;"	f
file_close	file.c	/^file_close (struct file *file) $/;"	f
file_deny_write	file.c	/^file_deny_write (struct file *file) $/;"	f
file_get_inode	file.c	/^file_get_inode (struct file *file) $/;"	f
file_length	file.c	/^file_length (struct file *file) $/;"	f
file_open	file.c	/^file_open (struct inode *inode) $/;"	f
file_read	file.c	/^file_read (struct file *file, void *buffer, off_t size) $/;"	f
file_read_at	file.c	/^file_read_at (struct file *file, void *buffer, off_t size, off_t file_ofs) $/;"	f
file_reopen	file.c	/^file_reopen (struct file *file) $/;"	f
file_seek	file.c	/^file_seek (struct file *file, off_t new_pos)$/;"	f
file_tell	file.c	/^file_tell (struct file *file) $/;"	f
file_write	file.c	/^file_write (struct file *file, const void *buffer, off_t size) $/;"	f
file_write_at	file.c	/^file_write_at (struct file *file, const void *buffer, off_t size,$/;"	f
filesys_create	filesys.c	/^filesys_create (const char *name, off_t initial_size) $/;"	f
filesys_disk	filesys.c	/^struct disk *filesys_disk;$/;"	v	typeref:struct:disk
filesys_done	filesys.c	/^filesys_done (void) $/;"	f
filesys_init	filesys.c	/^filesys_init (bool format) $/;"	f
filesys_open	filesys.c	/^filesys_open (const char *name)$/;"	f
filesys_remove	filesys.c	/^filesys_remove (const char *name) $/;"	f
find_cache	cache.c	/^struct cache* find_cache(disk_sector_t sec_no){$/;"	f
free_map	free-map.c	/^static struct bitmap *free_map;      \/* Free map, one bit per disk sector. *\/$/;"	v	typeref:struct:bitmap	file:
free_map_allocate	free-map.c	/^free_map_allocate (size_t cnt, disk_sector_t *sectorp) $/;"	f
free_map_close	free-map.c	/^free_map_close (void) $/;"	f
free_map_create	free-map.c	/^free_map_create (void) $/;"	f
free_map_file	free-map.c	/^static struct file *free_map_file;   \/* Free map file. *\/$/;"	v	typeref:struct:file	file:
free_map_init	free-map.c	/^free_map_init (void) $/;"	f
free_map_open	free-map.c	/^free_map_open (void) $/;"	f
free_map_release	free-map.c	/^free_map_release (disk_sector_t sector, size_t cnt)$/;"	f
frequency_of_writeback	cache.c	18;"	d	file:
fsutil_cat	fsutil.c	/^fsutil_cat (char **argv)$/;"	f
fsutil_get	fsutil.c	/^fsutil_get (char **argv)$/;"	f
fsutil_ls	fsutil.c	/^fsutil_ls (char **argv UNUSED) $/;"	f
fsutil_put	fsutil.c	/^fsutil_put (char **argv) $/;"	f
fsutil_rm	fsutil.c	/^fsutil_rm (char **argv) $/;"	f
in_use	directory.c	/^    bool in_use;                        \/* In use or free? *\/$/;"	m	struct:dir_entry	file:
indirect	inode.h	/^				disk_sector_t indirect;$/;"	m	struct:inode_disk
inode	directory.c	/^    struct inode *inode;                \/* Backing store. *\/$/;"	m	struct:dir	typeref:struct:dir::inode	file:
inode	file.c	/^    struct inode *inode;        \/* File's inode. *\/$/;"	m	struct:file	typeref:struct:file::inode	file:
inode	inode.h	/^struct inode{$/;"	s
inode_allow_write	inode.c	/^inode_allow_write (struct inode *inode) $/;"	f
inode_close	inode.c	/^inode_close (struct inode *inode) $/;"	f
inode_create	inode.c	/^inode_create (disk_sector_t sector, off_t length)$/;"	f
inode_deny_write	inode.c	/^inode_deny_write (struct inode *inode) $/;"	f
inode_disk	inode.h	/^struct inode_disk$/;"	s
inode_expand	inode.c	/^bool inode_expand(struct inode * extend_inode, off_t extend_length)\/\/LENGTH means real size to expand.$/;"	f
inode_get_inumber	inode.c	/^inode_get_inumber (const struct inode *inode)$/;"	f
inode_init	inode.c	/^inode_init (void) $/;"	f
inode_length	inode.c	/^inode_length (const struct inode *inode)$/;"	f
inode_open	inode.c	/^inode_open (disk_sector_t sector) $/;"	f
inode_read_at	inode.c	/^inode_read_at (struct inode *inode, void *buffer_, off_t size, off_t offset) $/;"	f
inode_remove	inode.c	/^inode_remove (struct inode *inode) $/;"	f
inode_reopen	inode.c	/^inode_reopen (struct inode *inode)$/;"	f
inode_sector	directory.c	/^    disk_sector_t inode_sector;         \/* Sector number of header. *\/$/;"	m	struct:dir_entry	file:
inode_write_at	inode.c	/^inode_write_at (struct inode *inode, const void *buffer_, off_t size,$/;"	f
length	inode.h	/^				off_t length;$/;"	m	struct:inode_disk
loaded	cache.h	/^				bool loaded;											\/*is this block used?(uploaded?)*\/$/;"	m	struct:cache
lookup	directory.c	/^lookup (const struct dir *dir, const char *name,$/;"	f	file:
magic	inode.h	/^				unsigned magic;$/;"	m	struct:inode_disk
make_cache	cache.c	/^struct cache* make_cache(disk_sector_t sec_no, bool dirty){$/;"	f
name	directory.c	/^    char name[NAME_MAX + 1];            \/* Null terminated file name. *\/$/;"	m	struct:dir_entry	file:
off_t	off_t.h	/^typedef int32_t off_t;$/;"	t
open_cnt	cache.h	/^				int open_cnt;											\/*#of open count*\/$/;"	m	struct:cache
open_cnt	inode.h	/^				int open_cnt;						\/*Number of openers*\/$/;"	m	struct:inode
open_inodes	inode.c	/^static struct list open_inodes;$/;"	v	typeref:struct:list	file:
pintos4	inode.c	/^bool pintos4 = true;$/;"	v
pos	directory.c	/^    off_t pos;                          \/* Current position. *\/$/;"	m	struct:dir	file:
pos	file.c	/^    off_t pos;                  \/* Current position. *\/$/;"	m	struct:file	file:
removed	inode.h	/^				bool removed;						\/*True if deleted*\/$/;"	m	struct:inode
sector	inode.h	/^				disk_sector_t sector;		\/*sector # of disk location*\/$/;"	m	struct:inode
sector_idx	cache.h	/^				disk_sector_t sector_idx;					\/*Sector No. *\/$/;"	m	struct:cache
start	inode.h	/^				disk_sector_t start;$/;"	m	struct:inode_disk
thread_function_wb_frequently	cache.c	/^static void thread_function_wb_frequently(void){$/;"	f	file:
unused	inode.h	/^				uint32_t unused[59];$/;"	m	struct:inode_disk
write_behind	cache.c	/^bool write_behind(struct cache* wb_cache){$/;"	f
